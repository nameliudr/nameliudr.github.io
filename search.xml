<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jjj]]></title>
    <url>%2F2019%2F09%2F10%2Fjjj%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[test-blog]]></title>
    <url>%2F2019%2F09%2F10%2Ftest-blog%2F</url>
    <content type="text"><![CDATA[一、缓存特征 二、LRU 三、缓存位置 四、CDN 五、缓存问题 六、数据分布 七、一致性哈希 参考资料 一、缓存特征 二、LRU以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下： 访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。 为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public class LRU&lt;K, V&gt; implements Iterable&lt;K&gt; &#123; private Node head; private Node tail; private HashMap&lt;K, Node&gt; map; private int maxSize; private class Node &#123; Node pre; Node next; K k; V v; public Node(K k, V v) &#123; this.k = k; this.v = v; &#125; &#125; public LRU(int maxSize) &#123; this.maxSize = maxSize; this.map = new HashMap&lt;&gt;(maxSize * 4 / 3); head = new Node(null, null); tail = new Node(null, null); head.next = tail; tail.pre = head; &#125; public V get(K key) &#123; if (!map.containsKey(key)) &#123; return null; &#125; Node node = map.get(key); unlink(node); appendHead(node); return node.v; &#125; public void put(K key, V value) &#123; if (map.containsKey(key)) &#123; Node node = map.get(key); unlink(node); &#125; Node node = new Node(key, value); map.put(key, node); appendHead(node); if (map.size() &gt; maxSize) &#123; Node toRemove = removeTail(); map.remove(toRemove.k); &#125; &#125; private void unlink(Node node) &#123; Node pre = node.pre; Node next = node.next; pre.next = next; next.pre = pre; node.pre = null; node.next = null; &#125; private void appendHead(Node node) &#123; Node next = head.next; node.next = next; next.pre = node; node.pre = head; head.next = node; &#125; private Node removeTail() &#123; Node node = tail.pre; Node pre = node.pre; tail.pre = pre; pre.next = tail; node.pre = null; node.next = null; return node; &#125; @Override public Iterator&lt;K&gt; iterator() &#123; return new Iterator&lt;K&gt;() &#123; private Node cur = head.next; @Override public boolean hasNext() &#123; return cur != tail; &#125; @Override public K next() &#123; Node node = cur; cur = cur.next; return node.k; &#125; &#125;; &#125;&#125;]]></content>
      <tags>
        <tag>test2</tag>
      </tags>
  </entry>
</search>
